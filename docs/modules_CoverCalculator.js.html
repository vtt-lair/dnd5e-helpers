<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Adding favicon -->
    

    <!-- Adding meta -->
    

    <!-- Adding external script-->
    

    <!-- Adding external style-->
    

    <!-- Adding scripts-->
    

    <!-- Adding style-->
    

    <!-- Adding overlay script-->
    

    <!-- Adding overlay style-->
    


    <title>
      modules/CoverCalculator.js
    </title>

    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/third-party/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/third-party/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/reset.css">
    <link type="text/css" rel="stylesheet" href="styles/clean-jsdoc-theme-base.css">
    <link type="text/css" rel="stylesheet" href="styles/clean-jsdoc-theme-dark.css">
    
    <svg aria-hidden="true" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
    style="display:none">
    <defs>
        <symbol id="copy-icon" viewbox="0 0 488.3 488.3">
            <g>
                <path
                    d="M314.25,85.4h-227c-21.3,0-38.6,17.3-38.6,38.6v325.7c0,21.3,17.3,38.6,38.6,38.6h227c21.3,0,38.6-17.3,38.6-38.6V124    C352.75,102.7,335.45,85.4,314.25,85.4z M325.75,449.6c0,6.4-5.2,11.6-11.6,11.6h-227c-6.4,0-11.6-5.2-11.6-11.6V124    c0-6.4,5.2-11.6,11.6-11.6h227c6.4,0,11.6,5.2,11.6,11.6V449.6z" />
                <path
                    d="M401.05,0h-227c-21.3,0-38.6,17.3-38.6,38.6c0,7.5,6,13.5,13.5,13.5s13.5-6,13.5-13.5c0-6.4,5.2-11.6,11.6-11.6h227    c6.4,0,11.6,5.2,11.6,11.6v325.7c0,6.4-5.2,11.6-11.6,11.6c-7.5,0-13.5,6-13.5,13.5s6,13.5,13.5,13.5c21.3,0,38.6-17.3,38.6-38.6    V38.6C439.65,17.3,422.35,0,401.05,0z" />
            </g>
        </symbol>
        <symbol id='search-icon' viewBox="0 0 512 512">
            <g>
                <g>
                    <path
                        d="M225.474,0C101.151,0,0,101.151,0,225.474c0,124.33,101.151,225.474,225.474,225.474    c124.33,0,225.474-101.144,225.474-225.474C450.948,101.151,349.804,0,225.474,0z M225.474,409.323    c-101.373,0-183.848-82.475-183.848-183.848S124.101,41.626,225.474,41.626s183.848,82.475,183.848,183.848    S326.847,409.323,225.474,409.323z" />
                </g>
            </g>
            <g>
                <g>
                    <path
                        d="M505.902,476.472L386.574,357.144c-8.131-8.131-21.299-8.131-29.43,0c-8.131,8.124-8.131,21.306,0,29.43l119.328,119.328    c4.065,4.065,9.387,6.098,14.715,6.098c5.321,0,10.649-2.033,14.715-6.098C514.033,497.778,514.033,484.596,505.902,476.472z" />
                </g>
            </g>
        </symbol>
        <symbol id="down-icon" viewBox="0 0 16 16">
            <path 
                fill-rule="evenodd" 
                clip-rule="evenodd" 
                d="M12.7803 6.21967C13.0732 6.51256 13.0732 6.98744 12.7803 7.28033L8.53033 11.5303C8.23744 11.8232 7.76256 11.8232 7.46967 11.5303L3.21967 7.28033C2.92678 6.98744 2.92678 6.51256 3.21967 6.21967C3.51256 5.92678 3.98744 5.92678 4.28033 6.21967L8 9.93934L11.7197 6.21967C12.0126 5.92678 12.4874 5.92678 12.7803 6.21967Z"
            >
            </path>
        </symbol>
    </defs>
</svg>
  </head>

  <body>

    <nav class="navbar" id="navbar">
      <div class="navbar-heading" id="navbar-heading"><a href="index.html"><h2 class="navbar-heading-text">Home</h2></a></div><div class="search-box" id="search-box"><div class="search-box-input-container"><input class="search-box-input" type="text" placeholder="Search..." id="search-box-input" /><svg class="search-icon" alt="search-icon"><use xlink:href="#search-icon"></use></svg></div><div class="search-item-container" id="search-item-container"><ul class="search-item-ul" id="search-item-ul"></ul></div></div><div class="sidebar-main-content" id="sidebar-main-content"><div class="accordion collapsed" id="1864653" > <h3 class="accordion-heading">Classes<svg><use xlink:href="#down-icon"></use></svg></h3><ul class="accordion-content"><li class="accordion-list" id=""><a href="ActionDialog.html">ActionDialog</a></li><li class="accordion collapsed child" id=220186><div class="accordion-heading child"><a href="ActionManagement.html">ActionManagement</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="ActionManagement.html#._patchToken">_patchToken</a></li><li data-type='method'><a href="ActionManagement.html#._shouldAddEffect">_shouldAddEffect</a></li><li data-type='method'><a href="ActionManagement.html#._updateCombat">_updateCombat</a></li></ul></li><li class="accordion collapsed child" id=6583341><div class="accordion-heading child"><a href="DnDWildMagic.html">DnDWildMagic</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="DnDWildMagic.html#.slotExpended">slotExpended</a></li></ul></li><li class="accordion collapsed child" id=7487237><div class="accordion-heading child"><a href="HelpersSettingsConfig.html">HelpersSettingsConfig</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="HelpersSettingsConfig.html#_onClickSubmenu">_onClickSubmenu</a></li><li data-type='method'><a href="HelpersSettingsConfig.html#activateListeners">activateListeners</a></li><li data-type='method'><a href="HelpersSettingsConfig.html#getData">getData</a></li></ul></li><li class="accordion-list" id=""><a href="LairActionDialog.html">LairActionDialog</a></li><li class="accordion collapsed child" id=6694962><div class="accordion-heading child"><a href="LairActionManagement.html">LairActionManagement</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="LairActionManagement.html#._createCombatant">_createCombatant</a></li><li data-type='method'><a href="LairActionManagement.html#._updateCombat">_updateCombat</a></li></ul></li><li class="accordion-list" id=""><a href="LegendaryActionDialog.html">LegendaryActionDialog</a></li><li class="accordion collapsed child" id=4177289><div class="accordion-heading child"><a href="LegendaryActionManagement.html">LegendaryActionManagement</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="LegendaryActionManagement.html#._createCombatant">_createCombatant</a></li><li data-type='method'><a href="LegendaryActionManagement.html#.hooks">hooks</a></li><li data-type='method'><a href="LegendaryActionManagement.html#.register">register</a></li><li data-type='method'><a href="LegendaryActionManagement.html#.settings">settings</a></li></ul></li><li class="accordion-list" id=""><a href="UpdateQueue.html">UpdateQueue</a></li><li class="accordion collapsed child" id=1472236><div class="accordion-heading child"><a href="WildMagicAPI.html">WildMagicAPI</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="WildMagicAPI.html#generateChatData">generateChatData</a></li><li data-type='method'><a href="WildMagicAPI.html#isTidesCharged">isTidesCharged</a></li><li data-type='method'><a href="WildMagicAPI.html#registerHandler">registerHandler</a></li><li data-type='method'><a href="WildMagicAPI.html#surge">surge</a></li><li data-type='method'><a href="WildMagicAPI.html#tidesRechargeUpdate">tidesRechargeUpdate</a></li><li data-type='method'><a href="WildMagicAPI.html#unregisterHandler">unregisterHandler</a></li></ul></li><li class="accordion-list" id=""><a href="WildMagicSurge.html">WildMagicSurge</a></li></ul> </div><div class="accordion collapsed" id="243369" > <h3 class="accordion-heading">Namespaces<svg><use xlink:href="#down-icon"></use></svg></h3><ul class="accordion-content"><li class="accordion collapsed child" id=9215153><div class="accordion-heading child"><a href="WildMagicAPI.templates.html">templates</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="WildMagicAPI.templates.html#.handler">handler</a></li><li data-type='method'><a href="WildMagicAPI.templates.html#.preCheck">preCheck</a></li></ul></li></ul> </div><div class="accordion collapsed" id="9665905" > <h3 class="accordion-heading">Global<svg><use xlink:href="#down-icon"></use></svg></h3><ul class="accordion-content"><li class="accordion-list" id=""><a href="global.html#queueUpdate">queueUpdate</a></li></ul> </div>
      

    </nav>
    <div class="navbar-ham" id="navbar-ham">
      <div>
        <div class="first"></div>
        <div class="second"></div>
        <div class="third"></div>
      </div>
    </div>

    <div id="main" class="main-content">
      
      <h1 id='page-title' class="page-title">
        modules/CoverCalculator.js
      </h1>
      

      



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { MODULE } from "../module.js";
import { Shape } from "./Shape.js";
import { Segment } from "./Segment.js";
import { Point } from "./Point.js";
import { logger } from "../logger.js";
import { queueUpdate } from "./update-queue.js"

const NAME = "CoverCalculator";

export class CoverCalculator{
  static register(){
    CoverCalculator.defaults();
    CoverCalculator.settings();
    CoverCalculator.hooks();
    CoverCalculator.patch();
    CoverCalculator.globals();
  }

  static defaults(){
    MODULE[NAME] = {
      coverData : {
        0 : { 
          label : MODULE.localize("DND5EH.LoS_nocover"), 
          value : 0, 
          color : "0xff0000", 
          icon : "" 
        },
        1 : { 
          label : MODULE.localize("DND5EH.LoS_halfcover"), 
          value : -2, 
          color : "0xffa500", 
          icon : "modules/dnd5e-helpers/assets/cover-icons/Half_Cover.svg" 
        },
        2 : { 
          label : MODULE.localize("DND5EH.LoS_34cover"), 
          value : -5, 
          color : "0xffff00", 
          icon : "modules/dnd5e-helpers/assets/cover-icons/ThreeQ_Cover.svg" 
        },
        3 : { 
          label : MODULE.localize("DND5EH.LoS_fullcover"), 
          value : -40, 
          color : "0x008000", 
          icon : "modules/dnd5e-helpers/assets/cover-icons/Full_Cover.svg"
        },
      },
      wall : {
        default : 3, 
        flag : "coverLevel",
        cover : {
          3 : [0,1,1,2,3],
          2 : [0,1,1,2,2],
          1 : [0,0,0,1,1],
        },
      },
      tile : {
        default : 0,
        flag : "coverLevel",
        cover : {
          3 : [0,1,1,2,3],
          2 : [0,1,1,2,2],
          1 : [0,0,0,1,1],
        },
      },
      token : {
        default : 1,
        flag : "coverLevel",
        cover : {
          3 : [0,1,1,2,3],
          2 : [0,1,1,2,2],
          1 : [0,1,1,1,1],
        }
      },
      ignoreCover:{ // Defining what number relates to what cover ignore level
        "none":0,
        "half":1,
        "threeQuarter":2,
        "full":3
      },
    }
  }

  static settings(){
    const config = false;
    const menuData = {
      debugDrawing : {
        scope : "client", config, groupd: 'misc', default : false, type : Boolean,
      },
      losSystem : {
        scope : "world", config, group : "system", default : 0, type : Number,
        choices : {
          0 : MODULE.localize("option.default.disabled"),
          1 : MODULE.localize("option.losOnTarget.center"),
          2 : MODULE.localize("option.losOnTarget.corner"),
        }
      },
      losOnTarget : {
        scope : "client", config, group : "system", default : 0, type : Boolean,
      }, losWithTiles : {
        scope : "world", config, group : "system", default : false, type : Boolean,
      },
      losWithTokens : {
        scope : "world", config, group : "system", default : false, type : Boolean,
      },
      coverTint : {
        scope : "world", config, group : "system", default : 0, type : String, 
        choices : {
          "DarkRed" : MODULE.localize("option.coverTint.red"),
          "CadetBlue" : MODULE.localize("option.coverTint.blue"),
          "DimGrey" : MODULE.localize("option.coverTint.grey"),
          "linear-gradient(to right, orange , yellow, green, cyan, blue, violet)" : MODULE.localize("option.coverTint.rainbow"),
        },
      },
      //losKeyBind : {
      //  scope : "world", config, group : "system", default : "", type : String,
      //},
      coverApplication : {
        scope : "world", config, group : "system", default : 0, type : Number, 
        choices : {
          0 : MODULE.format("option.default.disabled"),
          1 : MODULE.format("option.coverApplication.manual"),
          2 : MODULE.format("option.coverApplication.auto"),
        }
      },
      whisperToSelf:{
        scope : "client", config, group : "system", default : false, type : Boolean,
      },
      losMaskNPC : {
        scope : "world", config, group : "system", default : false, type : Boolean,
      },
      removeCover : {
        scope : "world", config, group : "combat", default : false, type : Boolean,
      },
      
    };

    MODULE.registerSubMenu(NAME, menuData, {tab: 'system'});

    const settingsData = {
      clearTargets : {
        scope : "world", config, group : "combat", default : false, type : Boolean,
      },
    }

    MODULE.applySettings(settingsData);

    CONFIG.DND5E.characterFlags.helpersIgnoreCover = {
      hint: "DND5EH.flagsNoCoverHint",
      name: "DND5EH.flagsNoCover",
      section: "Feats",
      choices:{
        0:MODULE.localize("DND5EH.flagsNoCoverOptionNone"),
        1:MODULE.localize("DND5EH.flagsNoCoverOptionHalf"),
        2:MODULE.localize("DND5EH.flagsNoCoverOptionThreeQ"),
        3:MODULE.localize("DND5EH.flagsNoCoverOptionFull")
      },
      type: Number
    };

    /* insert keybindings */
    game.keybindings.register(MODULE.data.name, "coverReport", {
      name: "Check Cover",
      hint: "Check the cover between the selected and hovered token",
      editable: [
        {
          key: "KeyR"
        }
      ],
      onDown: () => CoverCalculator._handleCover()
    });
  }

  static hooks(){
    Hooks.on(`renderTileConfig`, CoverCalculator._renderTileConfig);
    Hooks.on(`renderTokenConfig`, CoverCalculator._renderTokenConfig);
    Hooks.on(`renderWallConfig`, CoverCalculator._renderWallConfig);
    Hooks.on(`targetToken`, CoverCalculator._targetToken);
    Hooks.on(`renderChatMessage`, CoverCalculator._renderChatMessage);
    Hooks.on(`updateCombat`, CoverCalculator._updateCombat);
    Hooks.on(`deleteCombat`, CoverCalculator._deleteCombat);
    Hooks.on(`deleteCombatant`, CoverCalculator._deleteCombatant);
  }

  static patch(){
    CoverCalculator._patchToken();
    CoverCalculator._patchArray();
    CoverCalculator._patchTile();
    CoverCalculator._patchWall();
  }

  static globals(){
    window[NAME] = {
      Cover : CoverCalculator._Cover,
      Shape : CoverCalculator._Shape,
      Segment : CoverCalculator._Segment,
      Point : CoverCalculator._Point,
    };
  }

  /**
   * Hook Functions
   */
  static async _deleteCombat(combat, /*settings, id*/){
    if(MODULE.setting("losSystem") > 0 &amp;&amp; MODULE.isFirstGM()){
      for(let combatant of combat.combatants){
        const token = combatant?.token?.object;
        if(token)
          queueUpdate( () => {
            return Cover._removeEffect(token);
          });
      }
    }
  }

  static async _deleteCombatant(combatant, /*render*/){
    if(MODULE.setting("losSystem") > 0 &amp;&amp; MODULE.isFirstGM()){

      /* need to grab a fresh copy in case this
       * was triggered from a delete token operation,
       * which means this token is already deleted
       * and we need to do nothing
       */
      const tokenId = combatant.token?.id;
      const sceneId = combatant.parent.data.scene

      const tokenDoc = game.scenes.get(sceneId).tokens.get(tokenId);
      const token = tokenDoc?.object;

      if(token)
        queueUpdate( () => {
          return Cover._removeEffect(token);
        });
    }
  }
  
  static async _renderChatMessage(app, html, data){
    if(app.getFlag(MODULE.data.name, 'coverMessage') &amp;&amp; MODULE.setting("coverApplication") > 0 ){
      await MODULE.waitFor(() => !!canvas?.ready);

      const hasButtons = html.find('.cover-button').length > 0

      /* some messages may not have buttons to put listeners on */
      if(!hasButtons) return;

      const token = (await fromUuid(app.getFlag(MODULE.data.name, 'tokenUuid')))?.object;

      if(!token) return new Error(MODULE.localize("error.token.missing"));

      const a = html.find('#half')[0];
      const b = html.find('#34')[0];
      const c = html.find('#full')[0];
      const l = token.getCoverEffect()?.getFlag(MODULE.data.name, "level");

      if(l == 1) a.style.background = MODULE.setting("coverTint");
      else 
      if(l == 2) b.style.background = MODULE.setting("coverTint");
      else 
      if(l == 3) c.style.background = MODULE.setting("coverTint");

      //add listeners
      a.onclick =  () => Cover._toggleEffect(token, a, [b,c], 1);
      b.onclick = () => Cover._toggleEffect(token, b, [a,c], 2);
      c.onclick = () => Cover._toggleEffect(token, c, [a,b], 3);
    }
  }

  static _renderTileConfig(app, html){
    if(MODULE.setting("losSystem") === 0 || !MODULE.setting("losWithTiles") || app.object.data.overhead ) return;
    const adjacentElement = html.find('[data-tab="basic"] .form-group').last();
    CoverCalculator._injectCoverAdjacent(app, html, adjacentElement);
  }

  static _renderTokenConfig(app, html){
    if(MODULE.setting("losSystem") === 0 || !MODULE.setting("losWithTokens")) return;
    const adjacentElement = html.find('[data-tab="character"] .form-group').last();
    CoverCalculator._injectCoverAdjacent(app, html, adjacentElement);
  }

  static _renderWallConfig(app, html){
    if(MODULE.setting("losSystem") === 0) return;
    const ele = html.find('[name="ds"]')[0].parentElement;
    CoverCalculator._addToConfig(app, html, ele);
  }

  /* used for new style multi-tab config apps */
  // TODO functionalize HTML generation between these two functions
  static _injectCoverAdjacent(app, html, element) {
    /* if this app doesnt have the expected
     * data (ex. prototype token config),
     * bail out.
     */
    if (!app.object?.object) return;
    const status = app.object.object.coverValue() ?? 0;
    const selectHTML = `&lt;div class="form-group">
                          &lt;label>${MODULE.localize("DND5EH.LoS_providescover")}&lt;/label>
                          &lt;select name="flags.dnd5e-helpers.coverLevel" data-dtype="Number">
                            ${
                              Object.entries(MODULE[NAME].coverData).reduce((acc, [key,{label}]) => acc+=`&lt;option value="${key}" ${key == status ? 'selected' : ''}>${label}&lt;/option>`, ``)
                            }
                          &lt;/select>
                        &lt;/div>`;

    html.css("height", "auto");
    element.after(selectHTML);

  }

    /* used for "legacy" single page config apps */
    // TODO functionalize HTML generation between these two functions
    static _addToConfig(app, html, ele){

      /* if this app doesnt have the expected
       * data (ex. prototype token config),
       * bail out.
       */
      if (!app.object?.object) return;
      const status = app.object.object.coverValue() ?? 0;
      const selectHTML = `&lt;label>${MODULE.localize("DND5EH.LoS_providescover")}&lt;/label>
                          &lt;select name="flags.dnd5e-helpers.coverLevel" data-dtype="Number">
                            ${
                              Object.entries(MODULE[NAME].coverData).reduce((acc, [key,{label}]) => acc+=`&lt;option value="${key}" ${key == status ? 'selected' : ''}>${label}&lt;/option>`, ``)
                            }
                          &lt;/select>`;

                                html.css("height", "auto");
                                ele.insertAdjacentElement('afterend',MODULE.stringToDom(selectHTML, "form-group"));
                              }

  static _handleCover() {
    if ( !canvas.ready ) return false;
    const layer = canvas.activeLayer;
    if ( !(layer instanceof TokenLayer) ) return false;
    const hovered = layer.placeables.find(t => t._hover);
    if ( !hovered ){

      /* remove cover bonuses for any selected */
      for(const selected of canvas.tokens.controlled)
        queueUpdate( async () => {
          await Cover._removeEffect(selected);
        });

      return;
    }

    return CoverCalculator._runCoverCheck(canvas.tokens.controlled, hovered);
  }

  static async _runCoverCheck(sources, target){
    for(const selected of sources){
      if(selected.id === target.id) continue;
      let cover = new Cover(selected, target);

      //apply cover bonus automatically if requested
      queueUpdate( async () => {
        if(MODULE.setting("coverApplication") == 2) await cover.addEffect();
        await cover.toMessage();
      });
    }         
  }

  static async _targetToken(user, target, onOff){
    if(game.user !== user || MODULE.setting('losOnTarget') == false) return;

    if(user.targets.size == 1 &amp;&amp; onOff ){
      CoverCalculator._runCoverCheck(canvas.tokens.controlled, target)
    }

    if(user.targets.size != 1) {
      for(const selected of canvas.tokens.controlled)
        queueUpdate( async () => {
          await Cover._removeEffect(selected);
        });
    }
  }

  static async _updateCombat(combat, changed /*, options, userId */){
    /** only concerned with turn changes during active combat that is NOT turn 1 */  
    if(MODULE.setting("removeCover") &amp;&amp; MODULE.isFirstGM() &amp;&amp; MODULE.isTurnChange(combat, changed)){
      const token = combat.combatants.get(combat.previous.combatantId)?.token?.object;

      if(token)
        queueUpdate( async () => {
          await Cover._removeEffect(token);
        });
    }

    /* clear targets for all users on a turn change */
    if(MODULE.setting('clearTargets') &amp;&amp; MODULE.isTurnChange(combat,changed)){
        game.user.updateTokenTargets();
    }
  } 

  /**
   * Prototype Patch Functions
   */
  static _patchToken(){
    Token.prototype.ignoresCover = function(){
      let flagValue=this.actor?.getFlag("dnd5e", "helpersIgnoreCover") ?? 0;
      if (flagValue===true||flagValue==="true"){
        // used to be a boolean flag, if the flag is true either 
        // ,the value or a string due to AE shenanigans, treat is as it would have been before
        flagValue=MODULE[NAME].ignoreCover.threeQuarter
      }
      return flagValue
    }

    Token.prototype.coverValue = function(){
      const data = MODULE[NAME].token;
      return this.document.getFlag(MODULE.data.name, data.flag) ?? data.default;
    }

    Token.prototype.getCoverEffect = function(){
      return this?.getCoverEffects()[0] ?? undefined;
    }

    Token.prototype.getCoverEffects = function(){
      return this.actor?.effects.filter(e => e.getFlag(MODULE.data.name, "cover")) ?? [];
    }

    Token.prototype.setCoverValue = function(value){
      const data = MODULE[NAME].token;
      return this.document.setFlag(MODULE.data.name, data.flag, value);
    }
  }

  static _patchArray(){
    Array.prototype.count = function(value){
      return this.filter(x => x == value).length;
    }
  }

  static _patchTile(){
    Tile.prototype.coverValue = function(){
      const data = MODULE[NAME].tile;
      return this.document.getFlag(MODULE.data.name, data.flag) ?? data.default;
    }
  }

  static _patchWall(){
    Wall.prototype.coverValue = function(){
      const data = MODULE[NAME].wall;
      /* sight vs sense is a 0.9 vs 0.8 issue -- prefer 0.9, but fall back to 0.8 */
      const definedCover = this.document.getFlag(MODULE.data.name, data.flag);

      if (definedCover) return definedCover;

      /* otherwise, make an intelligent guess as to the default state based on the wall itself */
      /* sight vs sense is a 0.9 vs 0.8 issue -- prefer 0.9, but fall back to 0.8 */
      const sense = this.document.data.door &lt; CONST.WALL_DOOR_TYPES.DOOR ? this.document.data.sight
        : this.document.data.ds == CONST.WALL_DOOR_STATES.OPEN ? CONST.WALL_SENSE_TYPES.NONE 
        : this.document.data.sight;

      return sense >= CONST.WALL_SENSE_TYPES.LIMITED ? data.default : 0;
    }
  }

  /**
   * Global Accessors for Cover, Shape, Segment, and Point
   */
  static _Cover(...args){
    return new Cover(...args);
  }

  static _Shape(...args){
    return new Shape(...args);
  }

  static _Segment(...args){
    return new Segment(...args);
  }

  static _Point(...args){
    return new Point(...args);
  }
}

class Cover{
  data = {
    origin : {},
    target : {},
    tokens : {},
    tiles : {},
    walls : {},
    results : {},
    calculations : 0,
  };

  constructor(origin, target, padding = 5){
    if(origin.id === target.id) return new Error("Token Error");

    this.data.origin.object = origin;
    this.data.target.object = target;
    this.data.padding = canvas.grid.size * padding / 100;
    this.calculate();
  }

  calculate(){
    if(MODULE.setting("debugDrawing"))
      Cover._removeRays();

    this.buildTokenData();
    this.buildTileData();
    this.buildWallData();

    this.buildPoints();
    this.buildSquares();

    this.pointSquareCoverCalculator();
  }

  buildTokenData(){
    //create list of tokens to find collisions with
    this.data.tokens.objects = MODULE.setting("losWithTokens") ? canvas.tokens.placeables.filter(token => token.id !== this.data.origin.object.id &amp;&amp; token.id !== this.data.target.object.id) : [];
    this.data.tokens.shapes =  this.data.tokens.objects.map(token => Shape.buildX(token, this.data.padding, { cover : token.coverValue() }));

    if(MODULE.setting("debugDrawing"))
      this.data.tokens.shapes.forEach(shape => shape.draw());
  }

  buildTileData(){
    //create list of tiles to find collisions with
    this.data.tiles.objects = MODULE.setting("losWithTiles") ? canvas.background.placeables.filter(tile => (tile.coverValue() ?? 0) !== 0) : [];
    this.data.tiles.shapes = this.data.tiles.objects.map(tile => Shape.buildX({ x : tile.x, y : tile.y, w : tile.data.width, h : tile.data.height}, this.data.padding, { cover : tile.coverValue() }));

    if(MODULE.setting("debugDrawing"))
      this.data.tiles.shapes.forEach(shape => shape.draw());
  }

  buildWallData(){
    //create list of walls to find collisions with
    this.data.walls.objects = canvas.walls.placeables.filter(wall => wall.coverValue() !== 0 &amp;&amp; wall.document.data.ds !== CONST.WALL_DOOR_STATES.OPEN);
    this.data.walls.shapes = this.data.walls.objects.map(wall => Shape.buildWall(wall, { cover : wall.coverValue(), limited: wall.document.data.sight == CONST.WALL_SENSE_TYPES.LIMITED }));

    //filter out garbage walls (i.e. null)
    this.data.walls.shapes = this.data.walls.shapes.filter( shape => !!shape );

    if(MODULE.setting("debugDrawing"))
      this.data.walls.shapes.forEach(shape => shape.draw());
  }

  buildPoints(){
    this.data.origin.shapes = [];
    this.data.origin.points = [];

    if(MODULE.setting('losSystem') === 1)
      this.data.origin.points.push(new Point(this.data.origin.object.center));
    else{
      let c = Math.round(this.data.origin.object.w / canvas.grid.size), d = Math.round(this.data.origin.object.h / canvas.grid.size);
      for(let a = 0; a &lt; c; a++){
        for(let b = 0; b &lt; d; b++){
          let s = Shape.buildRectangle({
            x : this.data.origin.object.x + (a * canvas.grid.size),
            y : this.data.origin.object.y + (b * canvas.grid.size), 
            w : canvas.grid.size,
            h : canvas.grid.size,
          });
          this.data.origin.shapes.push(s);

          s.points.forEach(p =>{
            if(p instanceof Point &amp;&amp; !this.data.origin.points.reduce((a,b,i,o) => o.length == 0 ? a : (a || b.is(p)), false))
              this.data.origin.points.push(p);
          });
        }
      }
    }

    if(MODULE.setting("debugDrawing"))
      this.data.origin.shapes.forEach(shape => shape.draw());
  }

  buildSquares(){
    this.data.target.shapes = [];
    this.data.target.points = [];

    let c = Math.round(this.data.target.object.w / canvas.grid.size), d = Math.round(this.data.target.object.h / canvas.grid.size);
    for(let a = 0; a &lt; c; a++){
      for(let b = 0; b &lt; d; b++){
        let s = Shape.buildRectangle({
          x : this.data.target.object.x + (a * canvas.grid.size),
          y : this.data.target.object.y + (b * canvas.grid.size), 
          w : canvas.grid.size,
          h : canvas.grid.size,
        }, this.data.padding);
        this.data.target.shapes.push(s);
        s.points.forEach(p =>{
            if(p instanceof Point &amp;&amp; !this.data.target.points.reduce((a,b,i,o) => o.length == 0 ? a : (a || b.is(p)), false))
              this.data.target.points.push(p);
          });
      }
    }

    if(MODULE.setting("debugDrawing"))
      this.data.target.shapes.forEach(shape => shape.draw());
  }

  static _processLimitedSightCollisions(results = []){
    const numLimited = results.reduce( (acc, curr) => {
      if (curr.limited) acc++;
      return acc;
    }, 0)

    const toRemove = numLimited % 2;
    const processed = results.reduce( (acc, curr) => {

      if( acc.numSeen &lt; toRemove) {
        acc.numSeen++; 
      } else {
        acc.results.push(curr.cover);
      }

      return acc;
      
    },{results: [], numSeen: 0});

    return processed.results;
  }

  pointSquareCoverCalculator(){
    const results = this.data.origin.points.map(point =>{
      return this.data.target.shapes.map(square => {
        let collisions = square.points
          .map(p => {
            let s = new Segment({ points : [point, p]});

            let r = {
              tiles : Math.max.apply(null, Cover._processLimitedSightCollisions(this.data.tiles.shapes.map(shape => { this.data.calculations++; return shape.checkIntersection(s) }))),
              tokens : Math.max.apply(null, Cover._processLimitedSightCollisions(this.data.tokens.shapes.map(shape => { this.data.calculations++; return shape.checkIntersection(s) }))),
              walls : Math.max.apply(null, Cover._processLimitedSightCollisions(this.data.walls.shapes.map(shape => { this.data.calculations++; return shape.checkIntersection(s) }))),
            };

            r.total = Math.max(r.tiles, r.tokens, r.walls);

            if(MODULE.setting("debugDrawing")) s.draw({ color : MODULE[NAME].coverData[r.total &lt;= 0 ? 0 : r.total].color });

            return r;
        });

        let results = {
          tiles : getResult(
            MODULE[NAME].tile.cover,
            collisions.map(c => c.tiles),
          ),
          tokens : getResult(
            MODULE[NAME].token.cover,
            collisions.map(c => c.tokens),
          ),          
          walls : getResult(
            MODULE[NAME].wall.cover,
            collisions.map(c => c.walls),
          ),
        }

        results.total = Math.max(results.tiles, results.tokens, results.walls);

        logger.debug("Collisions | ", collisions);
        logger.debug("Results | ", results);

        return results;
      });
    });

    this.data.results.raw = results;
    this.data.results.ignore = this.data.origin.object.ignoresCover();
    this.data.results.corners = 0;
    this.data.results.cover = results.reduce((a,b) => Math.min(a, b.reduce((c,d) => Math.min(c, d.total), 3)),3);
    // If the current cover value is under the ignore threshold set cover to 0. ignore theshold goes from 1 to 3, cover from 0 to 3
    // none, half, threequarter, full
    this.data.results.cover = this.data.results.cover &lt;= this.data.results.ignore ? 0 : this.data.results.cover;
    this.data.results.label = MODULE[NAME].coverData[this.data.results.cover ?? 0].label;
    this.data.results.value = MODULE[NAME].coverData[this.data.results.cover ?? 0].value;

    function getResult(data, arr){
      return Math.max(...Object.entries(data).map(([key, coverArr]) => coverArr[arr.count(key)]));
    }
  }

  async toMessage(){
    this.data.origin.name = MODULE.sanitizeTokenName(this.data.origin.object, "losMaskNPC", "DND5EH.LoSMaskNPCs_creatureMask");
    this.data.target.name = MODULE.sanitizeTokenName(this.data.target.object, "losMaskNPC", "DND5EH.LoSMaskNPCs_creatureMask", false);
    this.data.target.name += '.'; //punctuation

    const appliedCover = this.data.origin.object.getCoverEffect()?.getFlag(MODULE.data.name, "level") ?? 0;
    let content = `
    &lt;div class="dnd5ehelpers">
      &lt;div class="dice-roll">
        &lt;i>${this.data.origin.name} ${MODULE.localize("DND5EH.LoS_outputmessage")} ${this.data.target.name}&lt;/i>
        &lt;div class="dice-result">
          &lt;div class="dice-formula">
            ${this.data.results.label}
          &lt;/div>
        &lt;/div>
      &lt;/div>
    &lt;/div>
    `;

    
    if(MODULE.setting("coverApplication") > 0){
      content += `
        &lt;div class="dnd5ehelpers">
          &lt;button class="cover-button half ${appliedCover == 1 ? "active" : ""} " id="half">
            &lt;img src="${MODULE[NAME].coverData[1].icon}">${MODULE.localize("DND5EH.LoS_halfcover")}
          &lt;/button>
          &lt;button class="cover-button quarters ${appliedCover == 2 ? "active" : ""} " id="34">
            &lt;img src="${MODULE[NAME].coverData[2].icon}">${MODULE.localize("DND5EH.LoS_34cover")}
          &lt;/button>
          &lt;button class="cover-button full ${appliedCover == 3 ? "active" : ""} " id="full">
            &lt;img src="${MODULE[NAME].coverData[3].icon}">${MODULE.localize("DND5EH.LoS_fullcover")}
          &lt;/button>
        &lt;/div>
      `;
    }
    
    return await ChatMessage.create({
      whisper : MODULE.setting("whisperToSelf")?[game.user]:ChatMessage.getWhisperRecipients("GM"),
      speaker : { alias : MODULE.localize("setting.coverApplication.name") },
      flags : {[MODULE.data.name] : { 
        ["coverMessage"] : true,
        ["tokenUuid"] : this.data.origin.object.document.uuid,
      }},
      content,
    });
  }

  async addEffect(){
    await Cover._addEffect( this.data.origin.object, this.data.results.cover );
  }

  async removeEffect(){
    await Cover._removeEffect(this.data.origin.object,);
  }

  static _removeRays(){
    for(let child of canvas.foreground.children.filter(c => c.constructor.name === "r"))
      canvas.foreground.removeChild(child);
  }

  static async _addEffect(token, cover){
    const { label, value } = MODULE[NAME].coverData[cover];
    await Cover._removeEffect(token);    
    if(cover == 0) return;

    const effectData = {
      changes : ["rwak", "rsak", "mwak", "msak"].map(s => ({ key : `data.bonuses.${s}.attack`, mode : CONST.ACTIVE_EFFECT_MODES.ADD , value })),
      icon : MODULE[NAME].coverData[cover].icon,
      label : `DnD5e Helpers - ${label}`,
      flags : { [MODULE.data.name] : { 
        ["cover"] : true, 
        ["level"] : cover 
      }},
      disabled : false, duration : {rounds : 1}, tint : "#747272",
    };

    await token.actor.createEmbeddedDocuments("ActiveEffect", [effectData]);
  }

  static async _removeEffect(token){
    const effects = token.getCoverEffects();
    return effects.length === 0 ? false : await token.actor.deleteEmbeddedDocuments("ActiveEffect", effects.map(e => e.id));
  }

  static async _toggleEffect(token, button, otherButtons, cover){
    let removed = await Cover._removeEffect(token);
    if(!removed || removed.reduce((a,b) => a || b.getFlag(MODULE.data.name, 'level') !== cover, false)){
      Cover._addEffect(token, cover);
      button.style.background = MODULE.setting("coverTint");
      otherButtons.forEach(b => b.style.background = "");
    }else{
      button.style.background = "";
    }

  }
}

/*
  target switching 
*/
</code></pre>
        </article>
    </section>




    </div>

    <footer class="footer" id="footer">
      
    </footer>

    <script src="scripts/third-party/prettify.js"></script>
    <script src="scripts/third-party/lang-css.js"></script>
    <script type="text/javascript" src="scripts/misc.js"></script>

    <script>prettyPrint();</script>
    <script src="scripts/linenumber.js"></script>
    <script src="scripts/fix-code-block.js"></script>
    <script src="scripts/fix-navbar.js"></script>
    
      <script src="scripts/search.js"></script>
      <script src="scripts/third-party/fuse.js"></script>
      <script>
        var list = [{"title":"ActionDialog","link":"<a href=\"ActionDialog.html\">ActionDialog</a>"},{"title":"ActionManagement","link":"<a href=\"ActionManagement.html\">ActionManagement</a>"},{"title":"ActionManagement._patchToken","link":"<a href=\"ActionManagement.html#._patchToken\">ActionManagement &rtrif; _patchToken</a>"},{"title":"ActionManagement._shouldAddEffect","link":"<a href=\"ActionManagement.html#._shouldAddEffect\">ActionManagement &rtrif; _shouldAddEffect</a>"},{"title":"ActionManagement._updateCombat","link":"<a href=\"ActionManagement.html#._updateCombat\">ActionManagement &rtrif; _updateCombat</a>"},{"title":"DnDWildMagic","link":"<a href=\"DnDWildMagic.html\">DnDWildMagic</a>"},{"title":"DnDWildMagic.slotExpended","link":"<a href=\"DnDWildMagic.html#.slotExpended\">DnDWildMagic &rtrif; slotExpended</a>"},{"title":"HelpersSettingsConfig","link":"<a href=\"HelpersSettingsConfig.html\">HelpersSettingsConfig</a>"},{"title":"HelpersSettingsConfig#_onClickSubmenu","link":"<a href=\"HelpersSettingsConfig.html#_onClickSubmenu\">HelpersSettingsConfig &rtrif; _onClickSubmenu</a>"},{"title":"HelpersSettingsConfig#activateListeners","link":"<a href=\"HelpersSettingsConfig.html#activateListeners\">HelpersSettingsConfig &rtrif; activateListeners</a>"},{"title":"HelpersSettingsConfig#getData","link":"<a href=\"HelpersSettingsConfig.html#getData\">HelpersSettingsConfig &rtrif; getData</a>"},{"title":"LairActionDialog","link":"<a href=\"LairActionDialog.html\">LairActionDialog</a>"},{"title":"LairActionManagement","link":"<a href=\"LairActionManagement.html\">LairActionManagement</a>"},{"title":"LairActionManagement._createCombatant","link":"<a href=\"LairActionManagement.html#._createCombatant\">LairActionManagement &rtrif; _createCombatant</a>"},{"title":"LairActionManagement._updateCombat","link":"<a href=\"LairActionManagement.html#._updateCombat\">LairActionManagement &rtrif; _updateCombat</a>"},{"title":"LegendaryActionDialog","link":"<a href=\"LegendaryActionDialog.html\">LegendaryActionDialog</a>"},{"title":"LegendaryActionManagement","link":"<a href=\"LegendaryActionManagement.html\">LegendaryActionManagement</a>"},{"title":"LegendaryActionManagement._createCombatant","link":"<a href=\"LegendaryActionManagement.html#._createCombatant\">LegendaryActionManagement &rtrif; _createCombatant</a>"},{"title":"LegendaryActionManagement.hooks","link":"<a href=\"LegendaryActionManagement.html#.hooks\">LegendaryActionManagement &rtrif; hooks</a>"},{"title":"LegendaryActionManagement.register","link":"<a href=\"LegendaryActionManagement.html#.register\">LegendaryActionManagement &rtrif; register</a>"},{"title":"LegendaryActionManagement.settings","link":"<a href=\"LegendaryActionManagement.html#.settings\">LegendaryActionManagement &rtrif; settings</a>"},{"title":"UpdateQueue","link":"<a href=\"UpdateQueue.html\">UpdateQueue</a>"},{"title":"WildMagicAPI","link":"<a href=\"WildMagicAPI.html\">WildMagicAPI</a>"},{"title":"WildMagicAPI#generateChatData","link":"<a href=\"WildMagicAPI.html#generateChatData\">WildMagicAPI &rtrif; generateChatData</a>"},{"title":"WildMagicAPI#isTidesCharged","link":"<a href=\"WildMagicAPI.html#isTidesCharged\">WildMagicAPI &rtrif; isTidesCharged</a>"},{"title":"WildMagicAPI#registerHandler","link":"<a href=\"WildMagicAPI.html#registerHandler\">WildMagicAPI &rtrif; registerHandler</a>"},{"title":"WildMagicAPI#surge","link":"<a href=\"WildMagicAPI.html#surge\">WildMagicAPI &rtrif; surge</a>"},{"title":"WildMagicAPI#tidesRechargeUpdate","link":"<a href=\"WildMagicAPI.html#tidesRechargeUpdate\">WildMagicAPI &rtrif; tidesRechargeUpdate</a>"},{"title":"WildMagicAPI#unregisterHandler","link":"<a href=\"WildMagicAPI.html#unregisterHandler\">WildMagicAPI &rtrif; unregisterHandler</a>"},{"title":"WildMagicSurge","link":"<a href=\"WildMagicSurge.html\">WildMagicSurge</a>"},{"title":"templates","link":"<a href=\"WildMagicAPI.templates.html\">templates</a>"},{"title":"WildMagicAPI.templates.handler","link":"<a href=\"WildMagicAPI.templates.html#.handler\">WildMagicAPI &rtrif; templates</a>"},{"title":"WildMagicAPI.templates.preCheck","link":"<a href=\"WildMagicAPI.templates.html#.preCheck\">WildMagicAPI &rtrif; templates</a>"},{"title":"queueUpdate","link":"<a href=\"global.html#queueUpdate\">queueUpdate</a>"}];
        var options = 
          setupSearch(list, options)
      </script>
    

    

    

    


  </body>

</html>
