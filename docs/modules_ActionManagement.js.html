<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Adding favicon -->
    

    <!-- Adding meta -->
    

    <!-- Adding external script-->
    

    <!-- Adding external style-->
    

    <!-- Adding scripts-->
    

    <!-- Adding style-->
    

    <!-- Adding overlay script-->
    

    <!-- Adding overlay style-->
    


    <title>
      modules/ActionManagement.js
    </title>

    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/third-party/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/third-party/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/reset.css">
    <link type="text/css" rel="stylesheet" href="styles/clean-jsdoc-theme-base.css">
    <link type="text/css" rel="stylesheet" href="styles/clean-jsdoc-theme-dark.css">
    
    <svg aria-hidden="true" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
    style="display:none">
    <defs>
        <symbol id="copy-icon" viewbox="0 0 488.3 488.3">
            <g>
                <path
                    d="M314.25,85.4h-227c-21.3,0-38.6,17.3-38.6,38.6v325.7c0,21.3,17.3,38.6,38.6,38.6h227c21.3,0,38.6-17.3,38.6-38.6V124    C352.75,102.7,335.45,85.4,314.25,85.4z M325.75,449.6c0,6.4-5.2,11.6-11.6,11.6h-227c-6.4,0-11.6-5.2-11.6-11.6V124    c0-6.4,5.2-11.6,11.6-11.6h227c6.4,0,11.6,5.2,11.6,11.6V449.6z" />
                <path
                    d="M401.05,0h-227c-21.3,0-38.6,17.3-38.6,38.6c0,7.5,6,13.5,13.5,13.5s13.5-6,13.5-13.5c0-6.4,5.2-11.6,11.6-11.6h227    c6.4,0,11.6,5.2,11.6,11.6v325.7c0,6.4-5.2,11.6-11.6,11.6c-7.5,0-13.5,6-13.5,13.5s6,13.5,13.5,13.5c21.3,0,38.6-17.3,38.6-38.6    V38.6C439.65,17.3,422.35,0,401.05,0z" />
            </g>
        </symbol>
        <symbol id='search-icon' viewBox="0 0 512 512">
            <g>
                <g>
                    <path
                        d="M225.474,0C101.151,0,0,101.151,0,225.474c0,124.33,101.151,225.474,225.474,225.474    c124.33,0,225.474-101.144,225.474-225.474C450.948,101.151,349.804,0,225.474,0z M225.474,409.323    c-101.373,0-183.848-82.475-183.848-183.848S124.101,41.626,225.474,41.626s183.848,82.475,183.848,183.848    S326.847,409.323,225.474,409.323z" />
                </g>
            </g>
            <g>
                <g>
                    <path
                        d="M505.902,476.472L386.574,357.144c-8.131-8.131-21.299-8.131-29.43,0c-8.131,8.124-8.131,21.306,0,29.43l119.328,119.328    c4.065,4.065,9.387,6.098,14.715,6.098c5.321,0,10.649-2.033,14.715-6.098C514.033,497.778,514.033,484.596,505.902,476.472z" />
                </g>
            </g>
        </symbol>
        <symbol id="down-icon" viewBox="0 0 16 16">
            <path 
                fill-rule="evenodd" 
                clip-rule="evenodd" 
                d="M12.7803 6.21967C13.0732 6.51256 13.0732 6.98744 12.7803 7.28033L8.53033 11.5303C8.23744 11.8232 7.76256 11.8232 7.46967 11.5303L3.21967 7.28033C2.92678 6.98744 2.92678 6.51256 3.21967 6.21967C3.51256 5.92678 3.98744 5.92678 4.28033 6.21967L8 9.93934L11.7197 6.21967C12.0126 5.92678 12.4874 5.92678 12.7803 6.21967Z"
            >
            </path>
        </symbol>
    </defs>
</svg>
  </head>

  <body>

    <nav class="navbar" id="navbar">
      <div class="navbar-heading" id="navbar-heading"><a href="index.html"><h2 class="navbar-heading-text">Home</h2></a></div><div class="search-box" id="search-box"><div class="search-box-input-container"><input class="search-box-input" type="text" placeholder="Search..." id="search-box-input" /><svg class="search-icon" alt="search-icon"><use xlink:href="#search-icon"></use></svg></div><div class="search-item-container" id="search-item-container"><ul class="search-item-ul" id="search-item-ul"></ul></div></div><div class="sidebar-main-content" id="sidebar-main-content"><div class="accordion collapsed" id="1864653" > <h3 class="accordion-heading">Classes<svg><use xlink:href="#down-icon"></use></svg></h3><ul class="accordion-content"><li class="accordion-list" id=""><a href="ActionDialog.html">ActionDialog</a></li><li class="accordion collapsed child" id=220186><div class="accordion-heading child"><a href="ActionManagement.html">ActionManagement</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="ActionManagement.html#._patchToken">_patchToken</a></li><li data-type='method'><a href="ActionManagement.html#._shouldAddEffect">_shouldAddEffect</a></li><li data-type='method'><a href="ActionManagement.html#._updateCombat">_updateCombat</a></li></ul></li><li class="accordion collapsed child" id=6583341><div class="accordion-heading child"><a href="DnDWildMagic.html">DnDWildMagic</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="DnDWildMagic.html#.slotExpended">slotExpended</a></li></ul></li><li class="accordion collapsed child" id=7487237><div class="accordion-heading child"><a href="HelpersSettingsConfig.html">HelpersSettingsConfig</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="HelpersSettingsConfig.html#_onClickSubmenu">_onClickSubmenu</a></li><li data-type='method'><a href="HelpersSettingsConfig.html#activateListeners">activateListeners</a></li><li data-type='method'><a href="HelpersSettingsConfig.html#getData">getData</a></li></ul></li><li class="accordion-list" id=""><a href="LairActionDialog.html">LairActionDialog</a></li><li class="accordion collapsed child" id=6694962><div class="accordion-heading child"><a href="LairActionManagement.html">LairActionManagement</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="LairActionManagement.html#._createCombatant">_createCombatant</a></li><li data-type='method'><a href="LairActionManagement.html#._updateCombat">_updateCombat</a></li></ul></li><li class="accordion-list" id=""><a href="LegendaryActionDialog.html">LegendaryActionDialog</a></li><li class="accordion collapsed child" id=4177289><div class="accordion-heading child"><a href="LegendaryActionManagement.html">LegendaryActionManagement</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="LegendaryActionManagement.html#._createCombatant">_createCombatant</a></li><li data-type='method'><a href="LegendaryActionManagement.html#.hooks">hooks</a></li><li data-type='method'><a href="LegendaryActionManagement.html#.register">register</a></li><li data-type='method'><a href="LegendaryActionManagement.html#.settings">settings</a></li></ul></li><li class="accordion-list" id=""><a href="UpdateQueue.html">UpdateQueue</a></li><li class="accordion collapsed child" id=1472236><div class="accordion-heading child"><a href="WildMagicAPI.html">WildMagicAPI</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="WildMagicAPI.html#generateChatData">generateChatData</a></li><li data-type='method'><a href="WildMagicAPI.html#isTidesCharged">isTidesCharged</a></li><li data-type='method'><a href="WildMagicAPI.html#registerHandler">registerHandler</a></li><li data-type='method'><a href="WildMagicAPI.html#surge">surge</a></li><li data-type='method'><a href="WildMagicAPI.html#tidesRechargeUpdate">tidesRechargeUpdate</a></li><li data-type='method'><a href="WildMagicAPI.html#unregisterHandler">unregisterHandler</a></li></ul></li><li class="accordion-list" id=""><a href="WildMagicSurge.html">WildMagicSurge</a></li></ul> </div><div class="accordion collapsed" id="243369" > <h3 class="accordion-heading">Namespaces<svg><use xlink:href="#down-icon"></use></svg></h3><ul class="accordion-content"><li class="accordion collapsed child" id=9215153><div class="accordion-heading child"><a href="WildMagicAPI.templates.html">templates</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="WildMagicAPI.templates.html#.handler">handler</a></li><li data-type='method'><a href="WildMagicAPI.templates.html#.preCheck">preCheck</a></li></ul></li></ul> </div><div class="accordion collapsed" id="9665905" > <h3 class="accordion-heading">Global<svg><use xlink:href="#down-icon"></use></svg></h3><ul class="accordion-content"><li class="accordion-list" id=""><a href="global.html#queueUpdate">queueUpdate</a></li></ul> </div>
      

    </nav>
    <div class="navbar-ham" id="navbar-ham">
      <div>
        <div class="first"></div>
        <div class="second"></div>
        <div class="third"></div>
      </div>
    </div>

    <div id="main" class="main-content">
      
      <h1 id='page-title' class="page-title">
        modules/ActionManagement.js
      </h1>
      

      



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { MODULE } from '../module.js';
import { logger } from '../logger.js';
import { queueUpdate } from './update-queue.js'

const NAME = "ActionManagement";

/**
 * ActionManagement
 *  This Module strictly manages token action economy per the dnd5e rules.
 */
export class ActionManagement{
  static register(){
    logger.info("Registering Action Management");
    this.defaults();
    this.settings();
    this.hooks();
    this.patch();
    this.globals();
  }

  static async defaults(){
    MODULE[NAME] = {
      /* Sub Module Constant Values */
      flagKey : "ActionManagement",
      default : {
        action : 0, reaction : 0, bonus : 0
      },
      img : {
        action : "modules/dnd5e-helpers/assets/action-markers/ACTION2.png",
        reaction : "modules/dnd5e-helpers/assets/action-markers/reaction.png",
        bonus : "modules/dnd5e-helpers/assets/action-markers/bonus.png",
        background : "modules/dnd5e-helpers/assets/action-markers/background.png",
      },
      orig : {
        height : 150, width : 150, x : 0, y : 0,
      }, 
      offset : {
        action : { h : 5, v : -1},
        reaction : { h : 2, v : -1},
        bonus : { h : 8, v : -1},
        background : { h : 5, v : -1}
      }
    };
  }

  static settings(){
    const config = false;
    const settingData = {
      actionMgmtEnable : {
        scope : "world", type : Number, group : "combat", default : 0, config,
        choices : {
          0 : MODULE.localize("option.default.disabled"),
          1 : MODULE.localize("option.default.enabled"),
        },
        onChange : async (v) =>{
          /**
           * @todo deal with updates based on rapid changes.
           */
        },
      },
      actionsAsStatus : {
        scope : "world", type : Number, group : "combat", default : 2, config,
        choices : {
          0 : MODULE.localize("option.default.disabled"),
          1 : MODULE.localize("option.default.enabled"),
          2 : MODULE.localize("option.actionsAsStatus.onlyReaction"),
        }
      },
      actionMgmtDisplay : {
        scope : "client", type : Number, group : "combat", default : 2, config,
        choices : {
          0 : MODULE.localize("option.default.disabled"),
          1 : MODULE.localize("option.default.enabled"),
          2 : MODULE.localize("option.default.enabledHover"),
        }
      },
      /** @todo localize */
      effectIconScale : {
        scope : "client", type : Number, group : "system", default : 1, config,
        onChange : () => {
          canvas?.tokens.placeables.forEach( token => token.drawEffects() );
        }
      }
      /**
       * @todo add new setting to handle container location
       * @todo add new setting for click handler (and dialog availability)
       */

    };

    MODULE.applySettings(settingData);

    /*
      additional settings
    */
  }

  static hooks(){
    Hooks.on(`updateCombat`, ActionManagement._updateCombat);
    Hooks.on(`controlToken`, ActionManagement._controlToken);
    Hooks.on(`updateToken`, ActionManagement._updateToken);
    Hooks.on(`createChatMessage`, ActionManagement._createChatMessage);
    Hooks.on(`deleteCombat`, ActionManagement._deleteCombat);
    Hooks.on(`deleteCombatant`, ActionManagement._deleteCombatant);
    Hooks.on('hoverToken', ActionManagement._hoverToken);
  }

  static patch(){
    this._patchToken();
  }

  static globals(){

  }

  /**
   * Hook Functions
   */
  static async _updateCombat(combat, changed, /*options, userid*/){
    if(MODULE.setting('actionMgmtEnable') == 0) return;

    logger.debug("_updateCombat | DATA | ", { 
      isFirstTurn : MODULE.isFirstTurn(combat,changed),
      isTurnChange : MODULE.isTurnChange(combat, changed),
      isFirstGM : MODULE.isFirstGM(),
      isFirstOwner : MODULE.isFirstOwner(combat.combatant?.token?.actor),
      combat,
      changed,
    });

    if(MODULE.isFirstTurn(combat, changed) &amp;&amp; MODULE.isFirstGM())
      for(let combatant of combat.combatants){
        const token = combatant.token.object;
        await token.resetActionFlag();
        await token.renderActionContainer(combatant.token.object._controlled &amp;&amp; MODULE.setting('actionMgmtDisplay') == 1 );
        await token.updateActionMarkers();
      }
    
    if(MODULE.isTurnChange(combat, changed) &amp;&amp; MODULE.isFirstOwner(combat.combatant.token.actor)){
      await combat.combatant.token.object.resetActionFlag();
    }
  }

  static _deleteCombat(combat, /* options, userId */){
      const mode = MODULE.setting('actionMgmtEnable');
      if(mode == 0) return;

      for(const combatant of combat.combatants){
        ActionManagement._deleteCombatant(combatant);
      }
  }

  static _deleteCombatant(combatant/*, options, userId */){

    /* need to grab a fresh copy in case this
     * was triggered from a delete token operation,
     * which means this token is already deleted
     * and we need to do nothing
     */
    const tokenId = combatant.token?.id;
    const sceneId = combatant.parent.data.scene

    queueUpdate(async () => {
      /* this retrieves a token DOCUMENT */
      const tokenDoc = game.scenes.get(sceneId).tokens.get(tokenId);
      const token = tokenDoc?.object;

      if(/*token?.hasActionFlag() &amp;&amp;*/ token.isOwner) {
        /* reset its flags to 0 to update status effect icons */
          await token.resetActionFlag();
          await token.updateActionMarkers(); 
          await token.removeActionFlag();
      }

      await token.removeActionContainer();

    });
  }

  static _controlToken(token, state){
    const mode = MODULE.setting('actionMgmtEnable');
    if(mode == 0) return;

    const display = MODULE.setting('actionMgmtDisplay');

    if(token.inCombat){

      queueUpdate( async () => {
        if(token.hasActionContainer()) token.toggleActionContainer(display === 0 || !state ? false : true);
        else await ActionManagement._renderActionContainer(token, display === 0 || !state ? false : true);
        return token.drawEffects();
      });

    }
  }

  /* this is where all clients should be updating their rendering, based on flags
   * set by the owner */
  static _updateToken(tokenDocument, update, /* options, id */){
    const mode = MODULE.setting('actionMgmtEnable');
    if(mode == 0 || !tokenDocument.inCombat) return;

    const display = MODULE.setting('actionMgmtDisplay');

    if("width" in update || "height" in update || "scale" in update){
      ActionManagement._renderActionContainer(tokenDocument.object, display === 0 || !tokenDocument.object._controlled ? false : true );
    }

    if("tint" in update || "img" in update || !!getProperty(update, `flags.${MODULE.data.name}`))
      tokenDocument.object.updateActionMarkers();
      
    logger.debug("_updateToken | Data | ", {
      tokenDocument, mode: display, update, container : tokenDocument.object.getActionContainer(),
    });
  }

  static async _createChatMessage(messageDocument, /*options, userId*/){
    const messageData = messageDocument.data;

    const types = Object.keys(MODULE[NAME].default);
    const speaker = messageData.speaker;

    logger.debug("_createChatMessage | DATA | ", {
      types, speaker, messageData,
    });

    /* check validity of message */
    if(!speaker || !speaker.scene || !speaker.token)  return;
    const token = await fromUuid(`Scene.${speaker.scene}.Token.${speaker.token}`);

    /* check that the token is in combat */
    if ( (token.combatant?.combat?.started ?? false) == false) return;

    let item_id = '';
    try{
      item_id = $(messageData.content).attr("data-item-id");
    }catch(e){ 
      /* any error in querying means its not the droids we are looking for */
      return;
    }

    logger.debug("_createChatMessage | DATA | ", {
      item_id, token,
    });

    if(!item_id || !token || !MODULE.isFirstOwner(token.actor)) return;

    const item = token.actor.items.get(item_id);

    logger.debug("_createChatMessage | DATA | ", {
      item,
    });

    if(!item || !types.includes(item.data.data.activation.type)) return;
    let type = item.data.data.activation.type;
    let cost = item.data.data.activation.cost ?? 1;
    
    logger.debug("_createChatMessage | DATA | ", {
      type,
    });

    type = ActionManagement._checkForReaction(type, token.combatant);
    token.object.iterateActionFlag(type, cost);
  }

  static _checkForReaction(actionType, combatant){

    if (!combatant) return actionType;

    /* if this is an action not on your turn, interpret as a reaction */
    if(actionType === 'action' &amp;&amp; combatant.id !== combatant.combat.current.combatantId) {
      return 'reaction';
    }

    return actionType;
  }

  static async _hoverToken(token, state){
    /* users can hover anything, but only 
     * should display on owned tokens 
     */
    if(!token.isOwner || !MODULE.setting('actionMgmtEnable')) return;
    const display = MODULE.setting('actionMgmtDisplay');

    /* main hover option must be enabled, and we must be in combat
     */
    if(display == 2 &amp;&amp; token.inCombat){
      if(!state) {
        setTimeout(function() {
          token.renderActionContainer(state);
          token.drawEffects();
        }, 100)}
      setTimeout(function() {
        if(!token._hover &amp;&amp; state) return;
        token.renderActionContainer(state);
        token.drawEffects();
      }, 500)
    }
  }

  /**
   * Patching Functions
   */
  static _patchToken(){
    Token.prototype.hasActionContainer = function(){
      return !!this.children?.find(i => i[NAME]);
    }

    Token.prototype.toggleActionContainer = function(state){
      let container = this.getActionContainer();
      if(container) container.visible = state === undefined ? !container.visible : state;
    }

    Token.prototype.getActionContainer = function(){
      return this.children?.find(i => i[NAME]);
    }

    Token.prototype.updateActionMarkers = function(){
      const flag = this.getActionFlag();
      const container = this.getActionContainer();

      if(!container || !flag) return;

      for(const type of Object.keys(MODULE[NAME].default)){
        const element = container.children.find(e => e.actionType == type);
        if(flag[type] > 0) {
          /* has been used */
          element.alpha = 0.2;
        } else {
          /* has been restored */
          element.alpha = 1;
        }

        /* update any needed status icons for this change (requires ownership) */
        if(this.isOwner) {
          if (ActionManagement._shouldAddEffect(type)) {
            queueUpdate( async () => {
              await this.toggleEffect( MODULE[NAME].img[type] , {active: flag[type] > 0 ? true : false} );
            });
          }
        }
      }
    }

    Token.prototype.getActionFlag = function(){
      return this.document.getFlag(MODULE.data.name, MODULE[NAME].flagKey);
    }

    Token.prototype.hasActionFlag = function(){
      return !!this.getActionFlag();
    }

    /** @return {Promise&lt;TokenDocument>} */
    Token.prototype.iterateActionFlag = function(type, value){

      /* dont mess with flags if I am not in combat */
      if (!this.combatant) return false;

      let flag = this.getActionFlag() ?? duplicate(MODULE[NAME].default);
      if(value === undefined) flag[type] += 1;
      else flag[type] = value;

      logger.debug("iterateActionFlag | DATA | ", {
        type, flag, token : this, scope : MODULE.data.name, key : MODULE[NAME].flagKey,
      });

      return this.document.setFlag(MODULE.data.name, MODULE[NAME].flagKey, flag);
      
    }

    Token.prototype.resetActionFlag = async function(){
      logger.debug("resetActionFlag | DATA | ", {
        token : this, default : MODULE[NAME].default,
      });

      /* force an update on reset */
      return await this.document.update({[`flags.${MODULE.data.name}.${MODULE[NAME].flagKey}`]: MODULE[NAME].default}, {diff: false})
    }

    Token.prototype.removeActionContainer = function(){
      if(this.hasActionContainer()) return this.removeChild(this.getActionContainer());
    }

    Token.prototype.removeActionFlag = async function(){
      if(!!this.getActionFlag()) return this.document.update({[`flags.${MODULE.data.name}.-=${MODULE[NAME].flagKey}`] : null });
    }

    Token.prototype.renderActionContainer = function(state){
      if(this.hasActionContainer())
        return this.toggleActionContainer(state);
      else
        return ActionManagement._renderActionContainer(this, state);
    }

    /* return: Promise&lt;setFlag> */
    Token.prototype.setActionUsed = async function(actionType, overrideCount = undefined) {
      const validActions = ['action', 'bonus', 'reaction'];
      if (validActions.includes(actionType)){

        /* if setting the action went well, return the resulting action usage object */
        const success = await this.iterateActionFlag(actionType, overrideCount); 
        if(success){
          return this.getActionFlag();
        }
      } 

      return false;
    }

    //from foundry.js:38015 as of v9.238
    Token.prototype._drawEffect = async function (src, index, bg, w, tint) {
      let tex = await loadTexture(src);
      let icon = this.hud.effects.addChild(new PIXI.Sprite(tex));
      
      //BEGIN D5H
      const scale = MODULE.setting('effectIconScale');
      icon.width = icon.height = w * scale;
      /* if the action hud is visible, offset the start offset
       * of the icons */
      const actionHeight = this.getActionContainer()?.visible ? this.getActionContainer().getLocalBounds().bottom : 0;

      const numColumns = Math.floor(this.data.width/scale * 5);
      icon.x = (index % numColumns) * icon.width;
      
      icon.y = actionHeight + Math.floor(index/numColumns) * icon.height;
      //END D5H

      if ( tint ) icon.tint = tint;
      bg.drawRoundedRect(icon.x + 1, icon.y + 1, icon.width - 2, icon.height - 2, 2);
    }
  }

  /**
   * Global Accessor Functions
   */

  /**
   * Module Specific Functions
   */
  static _shouldAddEffect(type) {
    const preDefAnswers = [false, true, type == 'reaction' ? true : false];
    const mode = MODULE.setting('actionMgmtEnable') != 0 ? MODULE.setting('actionsAsStatus') : 0;
    return preDefAnswers[mode];
  }

  static async _loadTextures(orig, obj = {}){
    const textures = {};
    for(let [k,v] of Object.entries(obj)){
      let t = await loadTexture(v);
      if(k !== "background") t.orig = orig;
      textures[k] = t;
    }
    return textures;
  }

  static async _renderActionContainer(token, state){
    /* Define Constants */
    const actions = token.getActionFlag() ?? duplicate(MODULE[NAME].default);
    const container = new PIXI.Container();
    const size = token.h, hAlign = token.w / 10, vAlign = token.h / 5, scale = 1/ (600/size);

    /* Build Textures, Sprites, Icons, and Container */
    container.setParent(token);
    container.sortableChildren = true;
    container[NAME] = true;
    container.visible = state;

    const textures = await ActionManagement._loadTextures(MODULE[NAME].orig, MODULE[NAME].img)

    for(let [k, v] of Object.entries(textures)){
      let s = new PIXI.Sprite(v);
      s.anchor.set(0.5);
      s.scale.set(scale);
      s.position.set(hAlign * MODULE[NAME].offset[k].h, vAlign /* MODULE[NAME].offset[k].v*/);
    
      if(k !== "background"){
        s.interactive = true;
        s.buttonMode = true;
        s.actionType = k;
        s.tint = 13421772;
        s.alpha = actions[k] === 0 ? 1 : 0.2;
        s.on("mousedown", async (event) => {
          const actions = token.getActionFlag() ?? (duplicate(MODULE[NAME].default));
          const container = token.getActionContainer();
          if(container.visible) {
            await token.iterateActionFlag(k, actions[k] > 0 ? 0 : 1);
          }
          logger.debug("_MouseDown | DATA |", { 
            event, token, container, actions
          });
        });
      }else{
        s.zIndex = -1000;
      }
      
      let i = container.addChild(s);

      logger.debug("_renderAction Container", {
        s, i, k, v
      });
    }

    logger.debug("_renderActionContainer | DATA | ", {
      actions, container, textures, token, state, size, hAlign, vAlign, scale
    });

    /* return Container*/
    return container;
  }
}
</code></pre>
        </article>
    </section>




    </div>

    <footer class="footer" id="footer">
      
    </footer>

    <script src="scripts/third-party/prettify.js"></script>
    <script src="scripts/third-party/lang-css.js"></script>
    <script type="text/javascript" src="scripts/misc.js"></script>

    <script>prettyPrint();</script>
    <script src="scripts/linenumber.js"></script>
    <script src="scripts/fix-code-block.js"></script>
    <script src="scripts/fix-navbar.js"></script>
    
      <script src="scripts/search.js"></script>
      <script src="scripts/third-party/fuse.js"></script>
      <script>
        var list = [{"title":"ActionDialog","link":"<a href=\"ActionDialog.html\">ActionDialog</a>"},{"title":"ActionManagement","link":"<a href=\"ActionManagement.html\">ActionManagement</a>"},{"title":"ActionManagement._patchToken","link":"<a href=\"ActionManagement.html#._patchToken\">ActionManagement &rtrif; _patchToken</a>"},{"title":"ActionManagement._shouldAddEffect","link":"<a href=\"ActionManagement.html#._shouldAddEffect\">ActionManagement &rtrif; _shouldAddEffect</a>"},{"title":"ActionManagement._updateCombat","link":"<a href=\"ActionManagement.html#._updateCombat\">ActionManagement &rtrif; _updateCombat</a>"},{"title":"DnDWildMagic","link":"<a href=\"DnDWildMagic.html\">DnDWildMagic</a>"},{"title":"DnDWildMagic.slotExpended","link":"<a href=\"DnDWildMagic.html#.slotExpended\">DnDWildMagic &rtrif; slotExpended</a>"},{"title":"HelpersSettingsConfig","link":"<a href=\"HelpersSettingsConfig.html\">HelpersSettingsConfig</a>"},{"title":"HelpersSettingsConfig#_onClickSubmenu","link":"<a href=\"HelpersSettingsConfig.html#_onClickSubmenu\">HelpersSettingsConfig &rtrif; _onClickSubmenu</a>"},{"title":"HelpersSettingsConfig#activateListeners","link":"<a href=\"HelpersSettingsConfig.html#activateListeners\">HelpersSettingsConfig &rtrif; activateListeners</a>"},{"title":"HelpersSettingsConfig#getData","link":"<a href=\"HelpersSettingsConfig.html#getData\">HelpersSettingsConfig &rtrif; getData</a>"},{"title":"LairActionDialog","link":"<a href=\"LairActionDialog.html\">LairActionDialog</a>"},{"title":"LairActionManagement","link":"<a href=\"LairActionManagement.html\">LairActionManagement</a>"},{"title":"LairActionManagement._createCombatant","link":"<a href=\"LairActionManagement.html#._createCombatant\">LairActionManagement &rtrif; _createCombatant</a>"},{"title":"LairActionManagement._updateCombat","link":"<a href=\"LairActionManagement.html#._updateCombat\">LairActionManagement &rtrif; _updateCombat</a>"},{"title":"LegendaryActionDialog","link":"<a href=\"LegendaryActionDialog.html\">LegendaryActionDialog</a>"},{"title":"LegendaryActionManagement","link":"<a href=\"LegendaryActionManagement.html\">LegendaryActionManagement</a>"},{"title":"LegendaryActionManagement._createCombatant","link":"<a href=\"LegendaryActionManagement.html#._createCombatant\">LegendaryActionManagement &rtrif; _createCombatant</a>"},{"title":"LegendaryActionManagement.hooks","link":"<a href=\"LegendaryActionManagement.html#.hooks\">LegendaryActionManagement &rtrif; hooks</a>"},{"title":"LegendaryActionManagement.register","link":"<a href=\"LegendaryActionManagement.html#.register\">LegendaryActionManagement &rtrif; register</a>"},{"title":"LegendaryActionManagement.settings","link":"<a href=\"LegendaryActionManagement.html#.settings\">LegendaryActionManagement &rtrif; settings</a>"},{"title":"UpdateQueue","link":"<a href=\"UpdateQueue.html\">UpdateQueue</a>"},{"title":"WildMagicAPI","link":"<a href=\"WildMagicAPI.html\">WildMagicAPI</a>"},{"title":"WildMagicAPI#generateChatData","link":"<a href=\"WildMagicAPI.html#generateChatData\">WildMagicAPI &rtrif; generateChatData</a>"},{"title":"WildMagicAPI#isTidesCharged","link":"<a href=\"WildMagicAPI.html#isTidesCharged\">WildMagicAPI &rtrif; isTidesCharged</a>"},{"title":"WildMagicAPI#registerHandler","link":"<a href=\"WildMagicAPI.html#registerHandler\">WildMagicAPI &rtrif; registerHandler</a>"},{"title":"WildMagicAPI#surge","link":"<a href=\"WildMagicAPI.html#surge\">WildMagicAPI &rtrif; surge</a>"},{"title":"WildMagicAPI#tidesRechargeUpdate","link":"<a href=\"WildMagicAPI.html#tidesRechargeUpdate\">WildMagicAPI &rtrif; tidesRechargeUpdate</a>"},{"title":"WildMagicAPI#unregisterHandler","link":"<a href=\"WildMagicAPI.html#unregisterHandler\">WildMagicAPI &rtrif; unregisterHandler</a>"},{"title":"WildMagicSurge","link":"<a href=\"WildMagicSurge.html\">WildMagicSurge</a>"},{"title":"templates","link":"<a href=\"WildMagicAPI.templates.html\">templates</a>"},{"title":"WildMagicAPI.templates.handler","link":"<a href=\"WildMagicAPI.templates.html#.handler\">WildMagicAPI &rtrif; templates</a>"},{"title":"WildMagicAPI.templates.preCheck","link":"<a href=\"WildMagicAPI.templates.html#.preCheck\">WildMagicAPI &rtrif; templates</a>"},{"title":"queueUpdate","link":"<a href=\"global.html#queueUpdate\">queueUpdate</a>"}];
        var options = 
          setupSearch(list, options)
      </script>
    

    

    

    


  </body>

</html>
